# BIPowerMatrix — Технічна Документація

## Огляд Системи

**Призначення:** Dashboard для управління виробництвом замороженої продукції на базі даних з POS-системи Poster.

**Архітектура:** Poster → n8n → Supabase → Next.js Dashboard

---

## 1. Джерела Даних

### 1.1. Poster POS API
- **URL:** `https://joinposter.com/api/`
- **Тип:** REST API
- **Дані:** Остатки товарів по магазинах (real-time)
- **Частота оновлення:** Щогодини через n8n workflow

### 1.2. n8n Integration
- **URL:** `https://n8n.dmytrotovstytskyi.online/`
- **Функція:** ETL pipeline
- **Процес:**
  1. GET запит до Poster API (`/storage/get_balances`)
  2. Трансформація даних
  3. INSERT/UPDATE в Supabase

---

## 2. База Даних (Supabase)

### 2.1. Підключення
```
Host: supabase.dmytrotovstytskyi.online
Port: 5432
Database: postgres
Schema: graviton (основна), public (proxy views)
```

### 2.2. Структура Схеми `graviton`

#### Таблиця: `daily_snapshots`
**Призначення:** Щоденні знімки остатків з Poster

| Колонка | Тип | Опис |
|---------|-----|------|
| snapshot_date | DATE | Дата знімка |
| store_code | INTEGER | Код магазину з Poster |
| store_name | TEXT | Назва магазину |
| product_code | INTEGER | Код товару з Poster |
| product_name | TEXT | Назва товару |
| stock_kg | NUMERIC | Залишок в кг |
| created_at | TIMESTAMPTZ | Час завантаження |

**Primary Key:** `(snapshot_date, store_code, product_code)`

**Джерело даних:** n8n workflow з Poster API

---

#### Таблиця: `manufactures`
**Призначення:** Виробничі цеха та їх прив'язка до магазинів

| Колонка | Тип | Опис |
|---------|-----|------|
| manufacture_id | SERIAL | ID цеху |
| manufacture_name | TEXT | Назва цеху (Гравітон, Садгора...) |
| capacity_kg | INTEGER | Денна потужність (кг) |
| active | BOOLEAN | Активний цех |

**Приклад даних:**
```
Гравітон → 450 кг/день → обслуговує [Кварц, Садгора, Хотинська...]
```

---

#### Таблиця: `manufacture_items`
**Призначення:** Зв'язок "Цех → Товар"

| Колонка | Тип | Опис |
|---------|-----|------|
| manufacture_id | INTEGER | FK → manufactures |
| product_code | INTEGER | Код товару |
| product_name | TEXT | Назва товару |
| category | TEXT | Категорія (Вареники, Пельмені...) |

**Логіка:** Вказує які товари виробляє конкретний цех.

---

### 2.3. VIEW: `distribution_base`
**Призначення:** Базова логіка розрахунку мінімальних залишків

```sql
CREATE VIEW graviton.distribution_base AS
SELECT
  ds.store_code AS "код_магазину",
  ds.store_name AS "назва_магазину",
  ds.product_code AS "код_продукту",
  ds.product_name AS "назва_продукту",
  mi.category AS category_name,
  
  -- Поточний залишок
  COALESCE(ds.stock_kg, 0) AS current_stock,
  
  -- Мінімальний запас = середнє за день × 4 дні
  COALESCE(
    AVG(ds.stock_kg) OVER (
      PARTITION BY ds.store_code, ds.product_code
      ORDER BY ds.snapshot_date
      ROWS BETWEEN 30 PRECEDING AND CURRENT ROW
    ) * 4,
    0
  ) AS min_stock,
  
  -- Середнє за день
  COALESCE(
    AVG(ds.stock_kg) OVER (
      PARTITION BY ds.store_code, ds.product_code
      ORDER BY ds.snapshot_date
      ROWS BETWEEN 30 PRECEDING AND CURRENT ROW
    ),
    0
  ) AS avg_sales_day,
  
  -- Дефіцит в кг
  GREATEST(
    0,
    min_stock - current_stock
  ) AS deficit_kg,
  
  -- Рекомендоване кг = дефіцит, округлений до 1 кг
  CEIL(GREATEST(0, min_stock - current_stock)) AS recommended_kg,
  
  -- Відсоток дефіциту
  CASE 
    WHEN min_stock > 0 THEN
      ROUND(((min_stock - current_stock) / min_stock * 100)::numeric, 1)
    ELSE 0
  END AS deficit_percent

FROM graviton.daily_snapshots ds
JOIN graviton.manufacture_items mi 
  ON ds.product_code = mi.product_code
WHERE ds.snapshot_date = CURRENT_DATE;
```

**Ключові розрахунки:**
1. **min_stock** = середнє за останні 30 днів × 4 дні запасу
2. **deficit_kg** = max(0, min_stock - current_stock)
3. **deficit_percent** = (deficit / min_stock) × 100

---

### 2.4. VIEW: `dashboard_deficit`
**Призначення:** Фінальна VIEW з пріоритетами для Dashboard

#### Схема `graviton.dashboard_deficit`:
```sql
CREATE VIEW graviton.dashboard_deficit AS
SELECT
  *,
  
  -- Пріоритет (числовий)
  CASE 
    WHEN deficit_percent >= 80 THEN 1  -- КРИТИЧНО
    WHEN deficit_percent >= 50 THEN 2  -- ВИСОКА
    WHEN deficit_percent >= 20 THEN 3  -- РЕЗЕРВ
    ELSE 4  -- НОРМАЛЬНО
  END as priority

FROM graviton.distribution_base
WHERE deficit_kg > 0;
```

#### Proxy VIEW `public.dashboard_deficit`:
```sql
CREATE VIEW public.dashboard_deficit AS
SELECT
  d."код_магазину",
  d."назва_магазину",
  d."код_продукту",
  d."назва_продукту",
  d.category_name,
  d.current_stock,
  d.min_stock,
  d.deficit_kg,
  d.recommended_kg,
  d.avg_sales_day,
  d.deficit_percent,
  d.priority as priority_number,
  
  -- Конвертація в string для фронтенду
  CASE 
    WHEN d.priority = 1 THEN 'critical'
    WHEN d.priority = 2 THEN 'high'
    WHEN d.priority = 3 THEN 'reserve'
    ELSE 'normal'
  END as priority
  
FROM graviton.dashboard_deficit d;

GRANT SELECT ON public.dashboard_deficit TO anon, authenticated;
```

**Чому proxy VIEW?**
- Supabase JS client працює зі схемою `public` за замовчуванням
- Дані зберігаються в `graviton`, але API звертається до `public`

---

### 2.5. VIEW: `dashboard_metrics`
**Призначення:** Агреговані метрики для карточок Dashboard

```sql
CREATE VIEW public.dashboard_metrics AS
SELECT
  COUNT(*) as total_items,
  
  -- Кількість по пріоритетах
  COUNT(*) FILTER (WHERE priority_number = 1) as critical_count,
  COUNT(*) FILTER (WHERE priority_number = 2) as high_count,
  COUNT(*) FILTER (WHERE priority_number = 3) as reserve_count,
  
  -- Сума рекомендованих кг
  COALESCE(SUM(CAST(recommended_kg AS NUMERIC)), 0) as total_kg,
  COALESCE(SUM(CAST(recommended_kg AS NUMERIC)) FILTER (WHERE priority_number = 1), 0) as critical_kg,
  COALESCE(SUM(CAST(recommended_kg AS NUMERIC)) FILTER (WHERE priority_number = 2), 0) as high_kg,
  COALESCE(SUM(CAST(recommended_kg AS NUMERIC)) FILTER (WHERE priority_number = 3), 0) as reserve_kg,
  
  -- Унікальні SKU
  COUNT(DISTINCT "код_продукту") as critical_sku_count
  
FROM public.dashboard_deficit
WHERE priority_number IN (1, 2, 3);

GRANT SELECT ON public.dashboard_metrics TO anon, authenticated;
```

**Результат (приклад):**
```json
{
  "total_kg": 396,
  "critical_kg": 82,
  "high_kg": 191,
  "reserve_kg": 123,
  "critical_sku_count": 73
}
```

---

## 3. Frontend (Next.js Dashboard)

### 3.1. API Endpoints

#### `GET /api/graviton/metrics`
**Призначення:** Отримати агреговані метрики для карточок

**SQL Query:**
```typescript
const { data } = await supabase
  .from('dashboard_metrics')
  .select('*')
  .single();
```

**Відповідь:**
```json
{
  "totalKg": 396,
  "criticalSKU": 73,
  "loadPercentage": 59,
  "breakdown": {
    "critical": 82,
    "high": 191,
    "reserve": 123
  }
}
```

---

#### `GET /api/graviton/deficit`
**Призначення:** Отримати детальний список дефіцитів

**SQL Query:**
```typescript
const { data } = await supabase
  .from('dashboard_deficit')
  .select('*')
  .in('priority_number', [1, 2, 3])
  .order('priority_number', { ascending: true })
  .order('deficit_percent', { ascending: false })
  .limit(1000);
```

**Відповідь:**
```json
[
  {
    "код_магазину": 44,
    "назва_магазину": "Магазин \"Білоруська\"",
    "код_продукту": 114,
    "назва_продукту": "Голубці з м'ясом",
    "category_name": "Голубці",
    "current_stock": 0,
    "min_stock": 4.72,
    "deficit_kg": 5,
    "recommended_kg": 5,
    "avg_sales_day": 1.18,
    "deficit_percent": 100,
    "priority_number": 1,
    "priority": "critical"
  }
]
```

---

### 3.2. UI Компоненти

#### Карточка "КРИТИЧНО"
**Джерело даних:** `GET /api/graviton/metrics`

**Логіка відображення:**
```typescript
// src/components/BIPowerMatrix.tsx
const { data: metrics } = useSWR('/api/graviton/metrics');

<MetricCard
  title="КРИТИЧНО"
  value={`${metrics.breakdown.critical} кг`}
  subtitle={`${metrics.criticalSKU} SKU`}
  variant="critical"
/>
```

**Що показує:**
- **critical_kg** — сума `recommended_kg` для товарів з `priority_number = 1`
- **critical_sku_count** — кількість унікальних товарів з дефіцитом >= 80%

---

#### Карточка "РЕЗЕРВ"
**Джерело даних:** `GET /api/graviton/metrics`

**Логіка відображення:**
```typescript
<MetricCard
  title="РЕЗЕРВ"
  value={`${metrics.breakdown.reserve} кг`}
  variant="reserve"
/>
```

**Що показує:**
- **reserve_kg** — сума `recommended_kg` для товарів з `priority_number = 3`
- Товари з дефіцитом 20-50%

---

#### Таблиця дефіцитів
**Джерело даних:** `GET /api/graviton/deficit`

**Фільтрація:**
```typescript
const filteredQueue = deficitData?.filter(item => 
  selectedPriorities.includes(item.priority)
) || [];
```

**Сортування:**
1. За `priority_number` (1 → 2 → 3)
2. За `deficit_percent` (100% → 0%)

---

## 4. Логіка Пріоритетів

### 4.1. КРИТИЧНО (priority = 1)
**Умова:** `deficit_percent >= 80%`

**Інтерпретація:** Товару менше 20% від мінімального запасу

**Приклад:**
```
min_stock = 5 кг
current_stock = 0 кг
deficit_percent = 100%
→ priority = 1 (КРИТИЧНО)
```

---

### 4.2. ВИСОКА (priority = 2)
**Умова:** `50% <= deficit_percent < 80%`

**Інтерпретація:** Товару 20-50% від мінімального запасу

**Приклад:**
```
min_stock = 10 кг
current_stock = 4 кг
deficit_percent = 60%
→ priority = 2 (ВИСОКА)
```

---

### 4.3. РЕЗЕРВ (priority = 3)
**Умова:** `20% <= deficit_percent < 50%`

**Інтерпретація:** Товару 50-80% від мінімального запасу

**Приклад:**
```
min_stock = 10 кг
current_stock = 7 кг
deficit_percent = 30%
→ priority = 3 (РЕЗЕРВ)
```

---

## 5. Data Flow (Повний Цикл)

```
1. Poster POS
   ↓ (Щогодини)
2. n8n ETL Pipeline
   ↓ (INSERT/UPDATE)
3. Supabase: graviton.daily_snapshots
   ↓ (SQL VIEW)
4. graviton.distribution_base (розрахунки min_stock, deficit)
   ↓ (SQL VIEW)
5. graviton.dashboard_deficit (додає priority)
   ↓ (Proxy VIEW)
6. public.dashboard_deficit (конвертує priority в string)
   ↓ (API Route)
7. Next.js: /api/graviton/deficit
   ↓ (SWR fetch)
8. React Component: <BIPowerMatrix />
   ↓ (Render)
9. User Interface (Dashboard)
```

---

## 6. Діаграма Зв'язків

```
┌─────────────┐
│ Poster API  │
└──────┬──────┘
       │ REST API
       ↓
┌─────────────┐
│     n8n     │ (ETL)
└──────┬──────┘
       │ PostgreSQL INSERT
       ↓
┌─────────────────────────────────────┐
│ Supabase (graviton schema)          │
│                                     │
│  ┌──────────────────┐               │
│  │ daily_snapshots  │               │
│  └────────┬─────────┘               │
│           │                         │
│           ↓                         │
│  ┌──────────────────┐               │
│  │ distribution_base│ (VIEW)        │
│  └────────┬─────────┘               │
│           │                         │
│           ↓                         │
│  ┌──────────────────┐               │
│  │dashboard_deficit │ (VIEW)        │
│  └────────┬─────────┘               │
└───────────┼─────────────────────────┘
            │ Proxy VIEW
            ↓
┌─────────────────────────────────────┐
│ Supabase (public schema)            │
│                                     │
│  ┌──────────────────┐               │
│  │dashboard_deficit │ (Proxy)       │
│  └────────┬─────────┘               │
│           │                         │
│  ┌──────────────────┐               │
│  │dashboard_metrics │ (Aggregation) │
│  └────────┬─────────┘               │
└───────────┼─────────────────────────┘
            │ Supabase JS Client
            ↓
┌─────────────────────────────────────┐
│ Next.js API Routes                  │
│                                     │
│  /api/graviton/deficit              │
│  /api/graviton/metrics              │
└───────────┬─────────────────────────┘
            │ HTTP JSON
            ↓
┌─────────────────────────────────────┐
│ React Dashboard (SWR)               │
│                                     │
│  <BIPowerMatrix />                  │
│  <MetricCard />                     │
└─────────────────────────────────────┘
```

---

## 7. Конфігурація

### 7.1. Environment Variables
```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=http://supabase.dmytrotovstytskyi.online
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ0eXAiOiJKV1Q...
```

### 7.2. Supabase Client
```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js'

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: { 
    persistSession: false,
    autoRefreshToken: false,
    detectSessionInUrl: false
  }
})

// Відключення Realtime (HTTP-only deployment)
if (typeof window !== 'undefined') {
  supabase.realtime.setAuth(null)
  supabase.realtime.disconnect()
}
```

---

## 8. Поточні Обмеження

1. **WebSocket не працює** — Self-hosted Supabase без SSL
2. **Realtime відключено** — Polling через SWR замість live updates
3. **Схема розбита** — Дані в `graviton`, API в `public` (proxy views)

---

## 9. TODO

- [ ] Додати SSL сертифікат для Supabase (Let's Encrypt)
- [ ] Увімкнути Realtime після SSL
- [ ] Оптимізувати VIEW `distribution_base` (індекси на `snapshot_date`)
- [ ] Додати історію змін пріоритетів
- [ ] Реалізувати notification при критичному дефіциті

---

**Версія:** 1.0  
**Дата оновлення:** 2025-02-04  
**Автор:** BIPowerMatrix Team